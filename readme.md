# 四种原则
单一职责原则, 就是一个类只做一个方向的事情
开放-封闭原则, 对扩展开放, 对修改封闭, 当需要修改时,我们就抽象一下, 来隔离以后同类型的修改
里氏替换原则, 子类要能够替换父类, 程序行为没有变化
依赖倒转原则, 细节依赖抽象, 抽象不能依赖细节, 面向接口编程

迪米特法则
如果两个类不直接通信, 那么这两个类就不应当发生直接的相互作用, 如果一个类需要调用另一个类的某个方法,
可以通过第三个类转发这个调用



# 实质分类:


### 策略模式, 简单工厂
共通点: 
	策略模式和简单工厂模式, 都是根据传递进来的参数, 选择不同的执行逻辑, 一个是执行方法, 一个是返回实例
适用场景:


### 简单工厂, 工厂方法, 抽象工厂
共通点:
	都是隐藏类的构造, 返回实例的方法
适用场景:
	


### 适配器, 装饰器, 代理模式
共通点:
	都是用一个类包装一下目标类, 先执行包装类, 在目标类前后执行一些特殊逻辑
适用场景:
	有一个基础的标准逻辑, 但是会有一些特殊的逻辑, 这个时候用, 除了用if之外,
	可以把标准流程提取成一个类或者方法, 然后用包一层的方法来进行if的判断
	这样的话不会影响阅读标准流程
	def format_run() {};
	def special_run() {xxx; format_run();};
	但是说到底, 还是没有省略if语句, 但是也不一定, 不一定所有的装饰都是要进行特殊判断
	有的可能是为了加个日志等等通用的操作


### 建造者, 外观模式, (原型方法: 也是用一个copy方法, 来隐藏构造细节)
##### 共通点:
	都是面对复杂的流程, 用一个类或者方法, 包装一下特定的流程
##### 适用场景


### 责任链, 状态模式
##### 共通点:
	都是用包含另一个实例, 本身无法处理时, 就交给另一个实例处理, 形成一个链条, 状态模式实质上也是如此
##### 适用场景:
	状态模式就很容易, 游戏登陆, 凡是有不同状态之间切换的系统, 都可以用状态模式
	责任链模式: 审批流程, 等等不同等级有不同权限的系统


### 组合模式
##### 共通点:
	(聚合, 手机软件)
##### 适用场景:
	

### 访问者模式
##### 共通点:
	行为和执行者分离开, 英语 -> 学生数组, 老师.教学(教英语行为){教英语行为(学生)}
##### 适用场景:

### 命令模式
##### 共通点:
	命令类里面有执行者类
##### 适用场景:

### 备忘录模式
##### 共通点:
	用一个类把目标类的当前属性都记录下来
##### 适用场景:

### 组合模式
##### 共通点:
	一个公司, 部门, 员工, 一个树形结构
##### 适用场景:

### 中介者模式
##### 共通点:
	联合国里面有所有国家的数组
##### 适用场景:

### 原型模式
##### 共通点:
	一个类写一个方法, 用于copy自己, 从而外界无需知道任何创建细节
##### 适用场景:

### 单例模式
##### 共通点:
	类的静态方法里
##### 适用场景:

