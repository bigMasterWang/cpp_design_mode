# 四种原则
单一职责原则, 就是一个类只做一个方向的事情
开放-封闭原则, 对扩展开放, 对修改封闭, 当需要修改时,我们就抽象一下, 来隔离以后同类型的修改
里氏替换原则, 子类要能够替换父类, 程序行为没有变化
依赖倒转原则, 细节依赖抽象, 抽象不能依赖细节, 面向接口编程

迪米特法则
如果两个类不直接通信, 那么这两个类就不应当发生直接的相互作用, 如果一个类需要调用另一个类的某个方法,
可以通过第三个类转发这个调用



# 实质分类:


### 策略模式, 简单工厂
共通点: 
	策略模式和简单工厂模式, 都是根据传递进来的参数, 选择不同的执行逻辑, 一个是执行方法, 一个是返回实例
适用场景:
	不同的类型, 相似但不同的流程, 比如返回加法, 减法操作等


### 简单工厂, 工厂方法, 抽象工厂
共通点:
	都是隐藏类的构造, 返回实例的方法
适用场景:
	根据参数, 返回一系列中不同的实例


### 适配器, 装饰器, 代理模式
共通点:
	都是用一个类包装一下目标类, 先执行包装类, 在目标类前后执行一些特殊逻辑
适用场景:
	有一个基础的标准逻辑, 但是会有一些特殊的逻辑, 这个时候用, 除了用if之外,
	可以把标准流程提取成一个类或者方法, 然后用包一层的方法来进行if的判断
	这样的话不会影响阅读标准流程
	def format_run() {};
	def special_run() {xxx; format_run();};
	但是说到底, 还是没有省略if语句, 但是也不一定, 不一定所有的装饰都是要进行特殊判断
	有的可能是为了加个日志等等通用的操作


### 建造者, 外观模式, (原型方法: 也是用一个copy方法, 来隐藏构造细节)
##### 共通点:
	都是面对复杂的流程, 用一个类或者方法, 包装一下特定的流程
##### 适用场景
	面对太复杂的系统, 用一个接口来代表一系列操作的整体逻辑, 客户操作时就不会少了步骤


### 责任链, 状态模式
##### 共通点:
	都是用包含另一个实例, 本身无法处理时, 就交给另一个实例处理, 形成一个链条, 状态模式实质上也是如此
##### 适用场景:
	状态模式就很容易, 游戏登陆, 凡是有不同状态之间切换的系统, 都可以用状态模式
	责任链模式: 审批流程, 等等不同等级有不同权限的系统


### 桥接模式, 组合模式
##### 共通点:
	大雁->聚合->雁群, 弱引用关系(手机和软件), 一个公司, 部门, 员工, 一个树形结构
	只不过桥接是一层的组合, 组合是递归的桥接
##### 适用场景:
	ECS


### 单例模式
##### 共通点:
	类的静态方法里
##### 适用场景:
	全局管理实例一般都是单例的, 各种manager


### 中介者模式
##### 共通点:
	联合国里面有所有国家的数组
##### 适用场景:
	逻辑和ui的交互


### 访问者模式
##### 共通点:
	行为和执行者分离开, 英语 -> 学生数组, 老师.教学(教英语行为){教英语行为(学生)}
##### 适用场景:
	技能系统, 购买行为等等游戏内的行为


### 备忘录模式, 原型模式
##### 共通点:
	都是把自己的属性做个快照, 备忘录是用别的类, 原型是用自己的类
##### 适用场景:
	有可能需要回退的系统, 剑圣分身
	

### 命令模式
##### 共通点:
	命令类里面有执行者类
##### 适用场景:
	感觉没什么地方用到, 如果需要让一系列逻辑顺序执行, 那直接顺序写逻辑就可以了
